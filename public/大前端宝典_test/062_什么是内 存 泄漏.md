# 什么是内 存 泄漏

内存泄漏是指应用程序中的 内存 不再被使用但仍然被占用，导致内存消耗逐渐增加，最终可能导致应用程序性能下降或崩溃。内存泄漏通常是由于开发者编写的代码未正确释放不再需要的对象或数据而导致的。

**特征:** 程序对 内存 失去控制

**内存泄漏的案例：**

- 意外的全局变量

```javascript
function someFunction() {  
// 这个变量会变成全局变量，并可能导致内存泄漏  
myObject = { /\* ... \*/ };  
}

```
- 闭包: 闭包可能会无意中持有对不再需要的变量或对象的引用，从而阻止它们被 垃圾回收 。

```javascript
function createClosure() {  
const data = \[/\* 大量数据 \*/\];  
return function() {  
// 闭包仍然持有对 'data' 的引用，即使它不再需要  
console.log(data);  
};  
}  
const closureFunction = createClosure();  
// 当 'closureFunction' 不再需要时，它仍然保留着 'data' 的引用，导致内存泄漏。

```
- 事件 监听器 : 忘记移除事件监听器可能会导致内存泄漏，因为与监听器相关联的对象将无法被 垃圾回收 。

```javascript
function createListener() {  
const element = document.getElementById('someElement');  
element.addEventListener('click', () => {  
// ...  
});  
}  
createListener();  
// 即使 'someElement' 从 DOM 中移除，该元素及其事件监听器仍将在内存中。

```
- 循环引用: 对象之间的循环引用会阻止它们被 垃圾回收 。

```javascript
function createCircularReferences() {  
const obj1 = {};  
const obj2 = {};  
obj1.ref = obj2;  
obj2.ref = obj1;  
createCircularReferences();  
// 由于循环引用，'obj1' 和 'obj2' 都将保留在内存中。

```
- setTimeout/setInterval: 使用 setTimeout 或 setInterval 时，如果没有正确清理，可能会导致内存泄漏，特别是当 回调函数 持有对大型对象的引用时。

```javascript
function doSomethingRepeatedly() {  
const data = \[/\* 大量数据 \*/\];  
setInterval(() => {  
// 闭包持有对 'data' 的引用，即使它不再需要  
console.log(data);  
}, 1000);  
}  
doSomethingRepeatedly();  
// 'doSomethingRepeatedly' 不再使用时，定时器仍然在运行，导致内存泄漏。

```
