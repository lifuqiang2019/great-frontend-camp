# 代码分析：以下代码触发了多少次回流？

```javascript
const box = document.getElementById('box');
const ol = box.offsetLeft;          // 读取布局信息
box.style.left = (ol + 10) + 'px';  // 修改布局样式
const ot = box.offsetTop;           // 读取布局信息
box.style.top = (ot + 10) + 'px';   // 修改布局样式
```

## 答案
**3 次**

## 详细解析

浏览器的渲染队列机制通常会合并多次 DOM 操作，在一次事件循环结束时统一执行。但是，当 JS 代码中**读取**某些布局属性（如 `offsetLeft`, `scrollTop`, `getComputedStyle`）时，为了返回最新的准确值，浏览器必须**强制**立即执行队列中待处理的排版操作。

1.  `const ol = box.offsetLeft;`
    *   **第 1 次回流**：浏览器需要计算并返回当前的 `offsetLeft`，因此强制刷新渲染队列。

2.  `box.style.left = ...`
    *   修改了样式，浏览器将此操作放入渲染队列，标记为“脏（Dirty）”，等待执行。

3.  `const ot = box.offsetTop;`
    *   **第 2 次回流**：为了获取准确的 `offsetTop`（包含刚才对 `left` 的修改可能带来的影响），浏览器再次强制刷新队列，执行之前的样式修改并重新计算布局。

4.  `box.style.top = ...`
    *   修改了样式，放入渲染队列。
    *   脚本执行结束，浏览器在下一个渲染周期处理剩余的队列。
    *   **第 3 次回流**：处理 `style.top` 的修改。
