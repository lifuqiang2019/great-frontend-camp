# Vue3.6 alien-signals - 状态各种位运算

```javascript
// JavaScript 中使用对象模拟 enum  
const ReactiveFlags = {  
None: 0, // 000000  
Mutable: 1 << 0, // 000001 1: 可变的（computed、ref）  
Watching: 1 << 1, // 000010 2: 监听中（effect）  
RecursedCheck: 1 << 2, // 000100 4: 递归检查中，用于依赖追踪  
Recursed: 1 << 3, // 001000 8: 已递归处理，防止重复处理  
Dirty: 1 << 4, // 010000 16: 脏数据，需要重新计算  
Pending: 1 << 5, // 100000 32: 等待处理，已标记但未执行  
}  
  
console.log('=== 位运算案例演示 ===\\n');  
  
function toBinary(num, bits = 8) {  
return num.toString(2).padStart(bits, '0');  
}  
  
// 1. 与运算 (&)：同为1时为1，否则为0  
console.log('1. 与运算 (&)：');  
// 000000 & 100000 = 000000  
console.log(toBinary(ReactiveFlags.None & ReactiveFlags.Pending, 6));  
// 100000 & 100000 = 100000  
console.log(toBinary(ReactiveFlags.Pending & ReactiveFlags.Pending, 6));  
// 000001 & 000010 = 000000  
console.log(toBinary(ReactiveFlags.Mutable & ReactiveFlags.Watching, 6));  
// 010000 & 100000 = 000000  
console.log(toBinary(ReactiveFlags.Dirty & ReactiveFlags.Pending, 6));  
console.log();  
  
// 2. 或运算 (|)：有一个为1时为1，全为0时为0  
console.log('2. 或运算 (|)：');  
// 000000 | 000001 = 000001  
console.log(toBinary(ReactiveFlags.None | ReactiveFlags.Mutable, 6));  
// 000001 | 000010 = 000011  
console.log(toBinary(ReactiveFlags.Mutable | ReactiveFlags.Watching, 6));  
// 010000 | 100000 = 110000  
console.log(toBinary(ReactiveFlags.Dirty | ReactiveFlags.Pending, 6));  
// 000001 | 000010 | 010000 = 010011  
console.log(toBinary(ReactiveFlags.Mutable | ReactiveFlags.Watching | ReactiveFlags.Dirty, 6));  
console.log();  
  
// 3. 异或运算 (^)：相同为0，不同为1  
console.log('3. 异或运算 (^)：');  
// 000000 ^ 000001 = 000001  
console.log(toBinary(ReactiveFlags.None ^ ReactiveFlags.Mutable, 6));  
// 000001 ^ 000001 = 000000  
console.log(toBinary(ReactiveFlags.Mutable ^ ReactiveFlags.Mutable, 6));  
// 000001 ^ 000010 = 000011  
console.log(toBinary(ReactiveFlags.Mutable ^ ReactiveFlags.Watching, 6));  
// 010000 ^ 100000 = 110000  
console.log(toBinary(ReactiveFlags.Dirty ^ ReactiveFlags.Pending, 6));  
console.log();  
  
// 4. 非运算 (~)：按位取反  
console.log('4. 非运算 (~)：');  
// ~000000 = 111111 (-1)  
console.log(~ReactiveFlags.None);  
// ~000001 = 111110 (-2)  
console.log(~ReactiveFlags.Mutable);  
// ~000010 = 111101 (-3)  
console.log(~ReactiveFlags.Watching);  
// ~100000 = 011111 (-33)  
console.log(~ReactiveFlags.Pending);  
console.log();  
  
// 5. 实际应用案例：标志位操作  
console.log('5. 实际应用案例：标志位操作');  
let flags = ReactiveFlags.None;  
  
// 添加标志位  
flags |= ReactiveFlags.Mutable;  
// 000000 | 000001 = 000001  
console.log(\`添加 Mutable 标志：${toBinary(flags, 6)}\`);  
  
flags |= ReactiveFlags.Watching;  
// 000001 | 000010 = 000011  
console.log(\`添加 Watching 标志：${toBinary(flags, 6)}\`);  
  
flags |= ReactiveFlags.Dirty;  
// 000011 | 010000 = 010011  
console.log(\`添加 Dirty 标志：${toBinary(flags, 6)}\`);  
  
// 检查标志位  
// 010011 & 000001 = 000001 (true)  
console.log(\`是否包含 Mutable：${(flags & ReactiveFlags.Mutable) !== 0}\`);  
// 010011 & 100000 = 000000 (false)  
console.log(\`是否包含 Pending：${(flags & ReactiveFlags.Pending) !== 0}\`);  
  
// 移除标志位  
flags &= ~ReactiveFlags.Watching;  
// 010011 & 111101 = 010001  
console.log(\`移除 Watching 标志：${toBinary(flags, 6)}\`);  
  
// 切换标志位  
flags ^= ReactiveFlags.Pending;  
// 010001 ^ 100000 = 110001  
console.log(\`切换 Pending 标志：${toBinary(flags, 6)}\`);  
  
flags ^= ReactiveFlags.Pending;  
// 110001 ^ 100000 = 010001  
console.log(\`再次切换 Pending 标志：${toBinary(flags, 6)}\`);

```
