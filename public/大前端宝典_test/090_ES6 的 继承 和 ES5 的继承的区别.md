# ES6 的 继承 和 ES5 的继承的区别

**ES6 类 继承 ：**

1.  **Class 和 extends 关键字：** ES6 引入了 class 和 extends 关键字，使得创建类和 继承 更加直观和易于理解。类提供了一种更面向对象的编程方式。
2.  **构造函数：** ES6 类 继承 通过构造函数 constructor 定义类的初始化逻辑，并通过 super 调用 父类 的构造函数。这使得继承更加符合直觉。
3.  **方法定义：** 类中的方法不再需要使用原型链，而是可以直接定义在类内部。这让方法的定义更集中和易读。
4.  **super 关键字：** super 关键字用于在子类中调用 父类 的方法，包括构造函数和普通方法。

**ES5 原型 继承 ：**

- **原型链 继承 ：**

```javascript
function Animal(name) {  
this.name = name;  
}  
  
Animal.prototype.speak = function() {  
console.log(this.name + ' makes a sound');  
};  
  
function Dog(breed) {  
this.breed = breed;  
}  
  
Dog.prototype = new Animal('Unknown');  
  
var myDog = new Dog('Golden Retriever');  
myDog.speak(); // 输出 "Unknown makes a sound"

```
- **缺点：**
- 属性共享： 子类共享了 父类 原型上的属性，一旦父类有引用类型，其中一个实例修改了这个引用类型的 属性值 ，会会影响所有其他实例。
- 不能传递参数： 无法向 父类 构造函数传参，因为父类构造函数已经被调用。
- **构造函数 继承 ：**

```javascript
function Animal(name) {  
this.name = name;  
}  
  
function Dog(name, breed) {  
Animal.call(this, name); // 使用构造函数继承，继承属性  
this.breed = breed;  
}  
  
var myDog = new Dog('Buddy', 'Golden Retriever');  
console.log(myDog.name); // 输出 "Buddy"

```
- 在这个示例中， Dog 构造函数内部调用了 Animal 构造函数，从而 继承 了 Animal 的属性。
- **缺点：**
- 属性 继承 ： 构造函数继承只继承了 父类 的属性，而没有继承父类的方法。子类无法访问父类原型上的方法。
- 属性复制： 将属性复制到子类实例中，而不是通过原型链共享。导致 内存 浪费，特别创建大量实例时。
- 不能 继承 方法： 子类无法继承 父类 原型上的方法，因此会导致代码重复和 内存 浪费。
- **寄生组合 继承**
- 结合了构造函数 继承 和原型继承，通过在子类构造函数内部调用 父类 构造函数来继承属性，然后通过 Object.create() 方法来继承父类原型上的方法。克服构造函数继承和原型继承各自的缺点。

```javascript
function Animal(name) {  
this.name = name;  
}  
  
Animal.prototype.speak = function() {  
console.log(this.name + ' makes a sound');  
};  
  
function Dog(name, breed) {  
// 使用构造函数继承，继承属性  
Animal.call(this, name);  
this.breed = breed;  
}  
  
// 使用 Object.create 继承原型  
Dog.prototype = Object.create(Animal.prototype);  
Dog.prototype.constructor = Dog; // 修复 constructor 引用  
  
Dog.prototype.speak = function() {  
console.log(this.name + ' barks');  
};  
  
var myDog = new Dog('Buddy', 'Golden Retriever');  
myDog.speak(); // 输出 "Buddy barks"

```
- 首先使用构造函数 继承 来继承属性，然后使用 Object.create(Animal.prototype) 继承了 父类 的原型。这种方式避免了原型链中属性共享的问题，并允许更灵活地定义子类的构造函数和方法。
