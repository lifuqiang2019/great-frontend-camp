# 在开发过程中，你如何确保代码的可维护性?

## 简短回答

可维护性的核心不是写出多牛的代码，而是写出让别人（或者三个月后的你）一眼能看懂的代码。我们通过**类型约束 (TS)** 来减少猜测，通过**纯函数**来降低副作用，通过**明确的架构分层** (UI 与逻辑分离) 来降低耦合。代码是写给人看的，顺便给机器执行。

---

## 1. 代码层面的防御 (TypeScript)

**类型即文档**。不要写 `any`，把 Interface 定义清楚，就是最好的文档。

```typescript
// Bad: 参数类型不明，调用者不知道传什么，也不知道返回什么
function getUser(id: any) { ... }

// Good: 明确的输入输出契约
interface User {
  id: string;
  name: string;
  role: 'admin' | 'user'; // 联合类型，比 string 更安全
}

function getUser(id: string): Promise<User> { ... }
```

## 2. 函数式编程思想

**纯函数 (Pure Function)** 是可维护性的基石。它的特点是：输入确定输出就确定，且不修改外部状态。

```javascript
// Impure: 依赖外部变量 count，且修改了原数组 arr，这种代码是 Bug 之源
let count = 0;
const add = (arr) => {
  count++;
  arr.push(count);
}

// Pure: 不修改原数据，返回新数据，无副作用。方便测试和并行计算。
const add = (arr, num) => [...arr, num];
```

## 3. 架构解耦 (SOLID - 单一职责)

在 React 开发中，最常见的反模式就是把数据请求、业务逻辑和 UI 渲染混在一个组件里。
**最佳实践**：UI 组件与逻辑组件分离 (Container/Presentational Pattern 或 Custom Hooks)。

```jsx
// Logic (Hook): 只负责拿数据，不负责怎么展示
const useUser = (id) => {
  const [user, setUser] = useState(null);
  useEffect(() => { fetchUser(id).then(setUser) }, [id]);
  return user;
}

// UI (Pure Component): 只负责展示，不关心数据怎么来的
// 这样的组件易于复用，也方便写单元测试
const UserCard = ({ user }) => (
  <div className="card">{user.name}</div>
);

// Usage: 组装逻辑和 UI
const UserContainer = ({ id }) => {
  const user = useUser(id);
  if (!user) return <Spinner />;
  return <UserCard user={user} />;
}
```
