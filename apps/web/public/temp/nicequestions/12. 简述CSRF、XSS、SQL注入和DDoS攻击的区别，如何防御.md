# 简述CSRF、XSS、SQL注入和DDoS攻击的区别，如何防御?

## 简短回答

Web 安全的核心在于**“不信任”**。**XSS** 是轻信了用户的输入（导致恶意脚本执行）；**CSRF** 是轻信了浏览器的 Cookie（导致被冒名顶替发请求）；**SQL 注入** 是轻信了参数（导致数据库被穿透）。防御的原则就是：永远不要相信客户端提交的任何数据，必须经过转义、验证和过滤。

---

## 1. XSS (跨站脚本攻击)

*   **攻击**：黑客在评论区提交了 `<script>stealCookies()</script>`，其他用户打开页面时脚本执行，Cookie 被偷。
*   **防御**：
    *   **转义**：现代框架 (React/Vue) 默认会自动转义插值。
    *   **CSP (内容安全策略)**：在 Header 中告诉浏览器，只允许加载哪里的脚本。
    
    ```http
    Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.com
    ```

## 2. CSRF (跨站请求伪造)

*   **攻击**：用户登录了银行网站 A，然后访问了恶意网站 B。B 网站偷偷发了一个请求给 A (转账)，浏览器会自动带上 A 的 Cookie，银行以为是用户操作的。
*   **防御**：
    *   **SameSite Cookie**：设置 Cookie 不允许跨站发送。
        ```http
        Set-Cookie: session_id=xyz; SameSite=Strict
        ```
    *   **CSRF Token**：请求必须带上一个黑客拿不到的随机 Token。

## 3. SQL 注入

*   **攻击**：登录框输入 `' OR '1'='1`，拼接到 SQL 里变成 `SELECT * FROM users WHERE name = '' OR '1'='1'`，直接绕过登录。
*   **防御**：
    *   **参数化查询 (Prepared Statements)**：不要拼接字符串！让数据库把参数只当成数据，而不是指令。

    ```javascript
    // 危险：字符串拼接
    const query = `SELECT * FROM users WHERE name = '${name}'`;
    
    // 安全：使用 ORM 或 预编译
    // 数据库会把 name 的内容转义，'1'='1' 只会被当成普通字符串
    User.findAll({ where: { name: req.body.name } });
    ```
