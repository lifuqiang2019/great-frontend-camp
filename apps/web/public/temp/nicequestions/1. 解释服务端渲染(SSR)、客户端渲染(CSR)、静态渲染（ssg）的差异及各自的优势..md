# 解释服务端渲染(SSR)、客户端渲染(CSR)、静态渲染（ssg）的差异及各自的优势.

## 简短回答

简单来说，**SSR (服务端渲染)** 是为了解决 SEO 和首屏白屏问题，适合内容型网站；**CSR (客户端渲染)** 适合交互复杂的后台管理系统，体验更像原生 App；**SSG (静态站点生成)** 是博客、文档类的首选，性能极致但缺乏实时性；而 **ISR (增量静态再生)** 则是 SSG 的升级版，允许在不重新构建的情况下更新部分页面，是目前 Next.js 等框架推荐的折中方案。

---

## 1. 核心差异对比

我们先从四个维度来对比这几种渲染模式，帮助你理清它们的适用场景：

| 特性 | CSR (客户端渲染) | SSR (服务端渲染) | SSG (静态站点生成) | ISR (增量静态再生) |
| :--- | :--- | :--- | :--- | :--- |
| **渲染时机** | 浏览器运行时 | 用户请求时 (Runtime) | 构建时 (Build time) | 构建时 + 运行时 (按需) |
| **数据实时性** | 高 | 高 | 低 (取决于构建频率) | 中 (取决于 Revalidate 周期) |
| **SEO 能力** | 弱 (依赖爬虫能力) | 强 | 强 | 强 |
| **首屏性能** | 慢 (白屏, 需下载 JS) | 快 (FP/FCP 快) | 极快 (纯 HTML) | 极快 |

## 2. 代码实现 (Next.js 示例)

光说不练假把式，我们看看在 Next.js 中，这几种模式是如何通过不同的 API 来体现的：

**SSR (getServerSideProps)**
用户每次刷新页面，服务器都会执行这个函数，拉取最新数据并生成 HTML。适合股票数据、实时新闻等场景。

```javascript
// 每次请求都会执行，获取最新数据
export async function getServerSideProps(context) {
  const res = await fetch(`https://api/data`)
  const data = await res.json()
  // 将数据作为 props 传递给组件
  return { props: { data } }
}
```

**SSG (getStaticProps)**
在 `npm run build` 的时候，页面就已经生成好了。用户访问时，服务器直接返回 HTML 文件，速度最快。

```javascript
// 只在 build 时执行一次
export async function getStaticProps() {
  const res = await fetch(`https://api/posts`)
  const posts = await res.json()
  return { props: { posts } }
}
```

**ISR (revalidate)**
这是 SSG 的“补丁”。它允许页面在构建后，每隔一段时间（如 10 秒）在后台重新生成一次。这样既保证了访问速度，又能展示相对新鲜的数据。

```javascript
export async function getStaticProps() {
  const res = await fetch(`https://api/posts`)
  const posts = await res.json()
  return {
    props: { posts },
    revalidate: 10, // 关键配置：每 10 秒重新生成一次页面
  }
}
```

## 3. 深度剖析：SSR 的代价 (Hydration)

SSR 虽然首屏快，但有一个隐性成本叫 **Hydration (注水)**。
服务端直出的 HTML 只是“干”的骨架，浏览器展示出画面后，还需要下载并执行 JS 来绑定事件（如点击按钮），这个过程就叫“注水”。

**问题**：如果 JS 体积太大，用户虽然能看到页面 (FCP 快)，但点了按钮没反应 (TTI 慢)，这会产生“恐怖谷”效应，体验极差。
**优化方向**：React 18 的 **Streaming SSR** 和 **Selective Hydration** 就是为了解决这个问题，允许分片传输 HTML 并按优先级注水，不再需要等所有 JS 都下载完。
