# React性能优化方案.

## 简短回答

React 性能优化的核心就两招：**“别多干活”**和**“别干重活”**。**React.memo / useMemo** 是为了防止不必要的组件重绘（别多干活）；**虚拟列表** 是为了只渲染用户看得见的内容（别干重活）。把这两点做好，配合正确的 State 管理，90% 的性能问题都能解决。

---

## 1. 减少不必要的渲染 (Render Control)

React 默认是“父组件更新，子组件无条件更新”。我们需要手动告诉它“停！”。

**React.memo & useMemo**
```jsx
// 1. 组件缓存：只有 props 真正变化时才重绘
const Child = React.memo(({ data }) => {
  console.log("Child Render");
  return <div>{data.value}</div>;
});

const Parent = () => {
  const [count, setCount] = useState(0);
  
  // 2. 数据缓存：必须缓存这个对象！
  // 否则每次 Parent 渲染都会生成一个新的 { value: 1 } 对象引用
  // 导致 Child 认为 props 变了，React.memo 失效
  const data = useMemo(() => ({ value: 1 }), []);

  return (
    <>
      <button onClick={() => setCount(c => c + 1)}>Count: {count}</button>
      <Child data={data} />
    </>
  );
};
```

## 2. 列表优化 (Virtual List)

如果你要渲染 10000 条数据，浏览器绝对卡死。
**虚拟列表 (Virtualization)** 的原理是：只渲染视口（屏幕上能看见的区域）内的 20 条数据。用户滚动时，动态替换这 20 条数据的内容。

```jsx
import { FixedSizeList as List } from 'react-window';

const Row = ({ index, style }) => (
  // style 属性是必须的，用于绝对定位每一行
  <div style={style}>Row {index}</div>
);

const Example = () => (
  <List
    height={500} // 视口高度
    itemCount={10000} // 总数据量
    itemSize={35} // 单行高度
    width={300}
  >
    {Row}
  </List>
);
```
