# Vite为什么比Webpack快?

## 简短回答

Vite 快的秘诀在于**“偷懒”**（按需编译）。Webpack 是把所有菜都备好（打包所有模块）才开饭，项目越大启动越慢；而 Vite 是你想吃什么（浏览器请求哪个模块）它才现切什么（实时编译）。加上它底层用了 Go 语言写的 **esbuild** 来处理依赖预构建，速度比 Node.js 快 10-100 倍。

---

## 1. 核心差异：Bundle vs Bundleless

*   **Webpack (Bundle-based)**：
    *   启动时：从 Entry 入口开始，递归分析整个依赖树，把所有文件打包成 Bundle，然后启动服务器。
    *   痛点：项目越大，构建越慢，改一行代码可能要等几秒。
*   **Vite (Native ESM)**：
    *   启动时：直接启动服务器，不做打包。
    *   运行时：利用浏览器原生的 **ES Module** 支持。当浏览器请求 `import ...` 时，Vite 拦截请求，做简单的编译后返回。

## 2. 双引擎架构

Vite 巧妙地结合了两种工具：
*   **Esbuild (Go)**：用于**依赖预构建**。它把 node_modules 里的 CommonJS 依赖转成 ESM，速度极快。
*   **Rollup**：用于**生产环境打包**。虽然开发环境不打包，但生产环境为了兼容性和代码体积，还是使用 Rollup 进行打包优化 (Tree Shaking)。

## 3. HMR (热更新) 原理对比

```javascript
// Webpack HMR
// 修改一个文件 -> 重新构建依赖图 -> 生成补丁 -> 客户端替换
// 随着项目变大，依赖图越复杂，HMR 延迟增加。

// Vite HMR
// 修改一个文件 -> Vite 只需要编译这一个文件 -> 浏览器重新请求该 ESM 模块
// 速度是 O(1) 的，无论项目多大，热更新都一样快。
```

## 4. 浏览器原生 ESM 请求

如果你打开浏览器的 Network 面板，你会看到大量独立的 `.js` 请求，这就是 Vite 的工作模式：
`GET /src/main.js`
`GET /src/App.vue` (被编译成 JS)
`GET /node_modules/.vite/vue.js` (预构建后的依赖)
