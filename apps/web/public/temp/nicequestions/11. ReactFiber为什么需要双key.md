# ReactFiber为什么需要双key?

## 简短回答

想象一下你在画画，如果直接在展示给观众的画布上修改，观众会看到画了一半的半成品（页面闪烁）。**双缓存**就是你在后台准备了另一块画布，在上面画好新的画面，然后“唰”地一下把两块画布交换，观众看到的永远是完整的画面。React Fiber 就是利用这个机制，在内存中构建好新的 Fiber 树，然后瞬间替换，实现了流畅且无闪烁的更新。

---

## 1. 什么是双缓存？

React 内部同时维护两棵 Fiber 树：
1.  **Current Tree**：屏幕上当前显示的内容对应的树。
2.  **WorkInProgress Tree (WIP)**：正在内存中构建的新树。

## 2. 工作流程图解

```mermaid
graph LR
    A[Current Tree] -- alternate --> B[WIP Tree]
    B -- alternate --> A
```

这两个树通过 `alternate` 指针互相连接。

*   **Render 阶段 (后台作画)**：
    React 在 WIP 树上进行计算 (Diff, Update)。因为是在内存里操作，用户看不见，所以这个过程可以被**中断** (Time Slicing)。比如用户突然打字，React 就暂停画画，先去处理打字，等空闲了再回来继续画。

*   **Commit 阶段 (交换画布)**：
    WIP 树构建完成，React 将 `FiberRoot.current` 指针从 Current Tree 指向 WIP Tree。
    这个赋值操作是**原子且同步**的，速度极快。

```javascript
// 伪代码：指针切换
function commitRoot(root, finishedWork) {
  // finishedWork 就是构建好的 WIP 树
  // 这一行代码执行完，UI 就更新了
  root.current = finishedWork; 
}
```

## 3. 优势

*   **无闪烁**：用户不会看到构建了一半的 UI。
*   **可中断渲染 (Concurrent Mode)**：这是 React 18 的核心。高优先级任务可以打断低优先级渲染，WIP 树可以随时丢弃重来，而不会影响当前显示的界面。
