# 在前端项目中，你如何管理和优化依赖项?

## 简短回答

依赖管理不仅仅是 `npm install` 那么简单，它关乎你的项目在一年后还能不能跑起来。核心在于三点：**锁版本**（避免“昨天还能跑今天挂了”）、**查漏洞**（供应链安全）以及**杜绝幽灵依赖**（Phantom Dependencies）。目前社区推荐的方案是 **pnpm + 严格的 .npmrc 配置 + 定期审计**。

---

## 1. 依赖管理痛点与解法

*   **版本不一致 (Works on my machine)**
    *   *问题*：你用了 `^1.0.0`，同事安装了 `1.0.1`，结果项目崩了。
    *   *解法*：强制提交 `package-lock.json` 或 `pnpm-lock.yaml`，并在项目中约束包管理器版本（如 `engines` 字段）。

*   **幽灵依赖 (Phantom Dependencies)**
    *   *问题*：你安装了 A，A 依赖了 B。你的代码里直接用了 B，但 `package.json` 里没写 B。某天 A 升级去掉了 B，你的代码就挂了。
    *   *解法*：使用 **pnpm**。pnpm 通过软链机制严格遵循依赖树，非扁平化 `node_modules`，只有在 `package.json` 声明过的包才能被 require/import。

## 2. 依赖配置最佳实践 (.npmrc)

在项目根目录创建 `.npmrc`，把规矩定死：

```ini
# .npmrc
save-exact=true        # 默认锁定精确版本号 (如 1.2.3 而非 ^1.2.3)，拒绝自动升级风险
engine-strict=true     # 强制检查 Node 版本，避免因 Node 版本差异导致的构建失败
registry=https://registry.npmmirror.com/ # 统一源，加速安装
```

## 3. 依赖治理工具链

除了规范，我们还需要工具来辅助治理：

*   **检查未使用的依赖 (减肥)**：
    ```bash
    npx depcheck
    # 它会告诉你哪些包在 package.json 里但代码没用到，赶紧删掉！
    ```

*   **安全审计 (保命)**：
    ```bash
    # 在 CI/CD 流程中加入，发现高危漏洞直接构建失败
    npm audit --production --audit-level=high
    ```

*   **Bundle 分析 (体检)**：
    如果你想知道打包出来的文件里到底包含了哪些乱七八糟的库，用这个：
    ```javascript
    // webpack.config.js
    const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
    module.exports = {
      plugins: [new BundleAnalyzerPlugin()]
    }
    ```
