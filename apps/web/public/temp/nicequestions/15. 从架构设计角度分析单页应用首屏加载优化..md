# 从架构设计角度分析单页应用首屏加载优化.

## 简短回答

SPA 首屏慢是天生的，因为浏览器要先下载完巨大的 JS 包才能开始干活。优化的核心思路就是三个字：**拆**、**预**、**哄**。
**拆**：把大包拆小，路由懒加载；
**预**：关键资源提前加载 (Preload)；
**哄**：在加载还没完成时，先给个骨架屏 (Skeleton) 哄哄用户，别让他看白屏。

---

## 1. 代码拆分 (Code Splitting)

不要把所有页面都打包进一个 `bundle.js`。使用 `React.lazy` 实现**路由级懒加载**。

```jsx
// 只有当用户访问 /about 时，才会去加载 About.js
const Home = React.lazy(() => import('./routes/Home'));
const About = React.lazy(() => import('./routes/About'));

function App() {
  return (
    // Suspense 用于在加载过程中展示 fallback 内容
    <Suspense fallback={<LoadingSkeleton />}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </Suspense>
  );
}
```

## 2. 构建优化 (Bundle Analyzer)

有时候包大是因为引入了不该引的东西。使用 `webpack-bundle-analyzer` 揪出元凶。

*   **Moment.js**：这货体积巨大且不支持 Tree Shaking。-> 替换为 **dayjs** (2KB)。
*   **Lodash**：不要 `import _ from 'lodash'` (全引)。-> 要 `import debounce from 'lodash/debounce'` (按需)。

## 3. 感知优化 (Skeleton)

既然物理时间无法缩短，那就缩短心理时间。
在 JS 下载和执行的几百毫秒里，展示一个灰色的骨架屏，让用户感觉“页面已经出来了，数据马上就来”。

```jsx
if (loading) {
  // 灰色占位图，模仿真实布局
  return <SkeletonCmp />; 
}
return <RealContent />;
```
