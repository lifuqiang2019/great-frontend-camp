# ES模块转CommonJS最大难点?

## 简短回答

这两者最大的区别在于：CommonJS (CJS) 是**运行时加载**，输出的是**值的拷贝**；而 ES Modules (ESM) 是**编译时静态分析**，输出的是**值的引用**。这导致了 ESM 支持 Tree Shaking（摇树优化），而 CJS 很难支持。目前 Node.js 已经逐步原生支持 ESM，它是前端模块化的未来。

---

## 1. 语法差异

**CommonJS (CJS)** - Node.js 传统标准
```javascript
// 运行时加载，同步执行
const fs = require('fs');
if (condition) {
  // 可以在语句块中动态加载，很灵活但难以静态分析
  const lib = require('./lib'); 
}
module.exports = { foo: 1 };
```

**ES Modules (ESM)** - 浏览器/ECMAScript 标准
```javascript
// 编译时静态分析，异步加载
import fs from 'fs'; // 必须在顶层，不能在 if 里
export const foo = 1;
// 支持 Top-level await
const data = await fetch('/api');
```

## 2. 核心难点：引用机制 (Live Binding)

这是面试常考点，也是最容易踩坑的地方。

*   **CJS (值拷贝)**：一旦输出，模块内部的变化不会影响外部。
    ```javascript
    // lib.js
    let count = 1;
    module.exports = { count, inc: () => count++ };
    
    // main.js
    const { count, inc } = require('./lib');
    inc();
    console.log(count); // 仍然是 1！因为 require 拿到的是 count 的副本
    ```

*   **ESM (引用绑定)**：导入的是只读引用，指向模块内部的内存地址。
    ```javascript
    // lib.js
    export let count = 1;
    export const inc = () => count++;
    
    // main.js
    import { count, inc } from './lib';
    inc();
    console.log(count); // 变成 2！实时反映模块内部的变化
    ```

## 3. 互操作 (Interoperability)

在 Node.js 中混用两者时要注意：
*   **ESM import CJS**：没问题，`import default` 会拿到 `module.exports`。
*   **CJS require ESM**：**不行**！因为 ESM 是异步的，CJS 是同步的。只能用 `await import(...)`。
