# 062_内存泄漏全解析：场景、排查与防范

## 1. 什么是内存泄漏？

**内存泄漏 (Memory Leak)** 是指程序中已分配的堆内存由于某种原因未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

简单来说：**借了不还，再借不难（但在计算机里，借了不还，内存迟早完蛋）。**

在 JavaScript 中，内存生命周期通常是：
1.  **分配**：申请内存（如 `let a = {}`）。
2.  **使用**：读写内存。
3.  **释放**：垃圾回收机制（GC）自动回收不再使用的内存。

**泄漏的核心原因**：本该被 GC 回收的对象，因为意外的引用链存在，导致 GC 认为它“还在使用中”，从而无法回收。

---

## 2. 常见的内存泄漏场景

### 2.1 意外的全局变量
非严格模式下，未声明的变量会挂载到全局对象（Window/Global）上。

```javascript
function foo() {
    // 意外创建全局变量
    bar = "这是一个很大的字符串...";
    // 或者 this 指向 window
    this.leak = new Array(10000);
}
```
**防范**：使用 `'use strict'`；使用 `let/const`；避免滥用全局变量。

### 2.2 被遗忘的定时器或回调
这是最经典也是最容易忽视的场景（正如我们在 Playwright MCP 演示中模拟的那样）。

```javascript
// 场景：组件销毁了，但定时器还在跑
function startTimer() {
    const hugeData = new Array(100000);
    // setInterval 的回调函数持有 hugeData 的闭包引用
    setInterval(() => {
        console.log("Timer is running...");
        // 只要定时器不清，hugeData 就永远无法回收
        const temp = hugeData; 
    }, 1000);
}
```
**防范**：在组件卸载（`beforeUnmount` / `useEffect return`）时执行 `clearInterval` / `clearTimeout`。

### 2.3 脱离 DOM 的引用 (Detached DOM)
当我们在 JS 中保存了对 DOM 节点的引用，即使该节点从 DOM 树中被删除了，它依然占据内存。

```javascript
let detachedNodes;

function create() {
    const ul = document.createElement('ul');
    for (let i = 0; i < 10; i++) {
        const li = document.createElement('li');
        ul.appendChild(li);
    }
    // detachedNodes 持有了 ul 的引用
    detachedNodes = ul; 
}

function deleteDom() {
    // 虽然 DOM 树里没有了，但 detachedNodes 还在引用
    // 导致整个 ul 及其子节点都无法回收
    document.body.removeChild(document.querySelector('ul'));
}
```
**防范**：使用 `WeakMap` 存储 DOM 引用，或在删除 DOM 后手动将 JS 引用置为 `null`。

### 2.4 不当的闭包
虽然闭包是 JS 的特性，但如果闭包作用域链中保存了过大的对象且未释放，就是泄漏。

```javascript
function outer() {
    const bigData = new Array(1000000);
    return function inner() {
        // inner 即使没用到 bigData，某些旧引擎或特定实现下
        // 可能会因为共享作用域环境而导致 bigData 无法释放
        console.log("Hello");
    }
}
```

### 2.5 未清理的 Console 输出
**冷知识**：在开发环境中，`console.log(obj)` 会导致浏览器为了能在控制台查看对象详情，而始终保持对该对象的引用。
**防范**：生产环境（Production）构建时使用插件（如 `terser-webpack-plugin`）移除所有 `console`。

---

## 3. 内存泄漏排查实战

### 3.1 Chrome DevTools 工具链
1.  **Performance (性能面板)**:
    *   勾选 `Memory`。
    *   录制一段时间的操作。
    *   观察 **JS Heap** 曲线。如果曲线呈现“阶梯状上升”且没有下降趋势，极大概率存在泄漏。

2.  **Memory (内存面板)**:
    *   **Heap Snapshot (堆快照)**:
        *   分别在操作前和操作后拍快照。
        *   使用 `Comparison` 视图对比，查看 `Delta` 为正值的对象。
    *   **Allocation Instrumentation on Timeline**:
        *   实时查看内存分配的竖条。蓝色竖条代表分配，灰色代表释放。如果蓝色竖条持续存在且不变成灰色，说明未被回收。

### 3.2 自动化检测 (Playwright MCP)
正如我们之前的演示，利用 **Playwright** 结合 **MCP** 可以实现自动化内存泄漏检测：
1.  **自动化操作**：模拟用户长时间交互。
2.  **JS 句柄分析**：通过 `page.evaluate` 定期检查 `window.performance.memory.usedJSHeapSize`。
3.  **阈值报警**：如果内存增长超过阈值（如连续 5 次增长），自动截图并报告。

---

## 4. 解决方案与最佳实践

1.  **手动释放**：
    *   定时器：`clearInterval(timerId)`
    *   事件监听：`removeEventListener`
    *   对象引用：`obj = null`

2.  **使用 WeakMap / WeakSet**：
    *   弱引用不会阻止垃圾回收。适合用于存储 DOM 节点相关的数据。

3.  **框架层面的生命周期管理**：
    *   **Vue**: `beforeUnmount` / `unmounted` 中清理。
    *   **React**: `useEffect` 的 cleanup 函数中清理。

4.  **避免滥用全局变量**：
    *   尽量使用模块化（Module）或函数作用域。

---

## 5. 代码示例：修复 062 题的泄漏

**泄漏版：**
```javascript
function startLeak() {
    const data = [];
    setInterval(() => {
        data.push(new Array(10000)); // 持续增长，无法回收
    }, 100);
}
```

**修复版：**
```javascript
function safeTimer() {
    const data = [];
    const timerId = setInterval(() => {
        if (data.length > 100) {
            // 1. 设置阈值清理
            data.length = 0; 
            // 2. 或者停止定时器
            clearInterval(timerId); 
            return;
        }
        data.push(new Array(10000));
    }, 100);
    
    // 返回清理函数供外部调用
    return () => clearInterval(timerId);
}
```
