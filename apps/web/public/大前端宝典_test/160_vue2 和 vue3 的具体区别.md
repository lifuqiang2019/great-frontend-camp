# vue2 和 vue3 的具体区别

1.  **响应式系统：**

- Vue 2 使用 Object.defineProperty 来实现其响应式系统。这种方法有一些限制，例如无法 检测属性的添加或删除 ，以及无法直接处理数组索引和长度的变化。
- Vue 3 则采用了基于 ES6 Proxy 的响应式系统，这允许 Vue 拦截对象的任何属性的读取和写入操作，提供更强大和灵活的响应式能力。这也使得 Vue 3 能够检测属性的添加和删除，以及更有效地处理数组更新。

1.  **组合式 API：**

- Vue 2 主要通过选项式 API（如 data , methods , computed 等）进行组件的逻辑组织。
- Vue 3 引入了组合式 API（如 ref , reactive , computed , watch ），这为逻辑复用和代码组织提供了更灵活的方式。

1.  **性能相关：**

- Vue 3 在性能方面有显著提升。它包括更小的打包大小、更快的虚拟 DOM 重写、更高效的组件初始化等。
- Vue 2 相比之下在性能方面相对较慢，尤其是在处理大型应用和复杂组件时。

1.  **TypeScript 支持：**

- Vue 3 从一开始就以 TypeScript 编写，提供更好的 TypeScript 支持。
- Vue 2 对 TypeScript 的支持是有限的，通常需要额外的配置和工具来实现更好的集成。

1.  **新特性和改进：**

- Vue 3 引入了多个新特性，如 Teleport 、 Fragment 、 Suspense 等，为开发提供了更多的可能性和便利。

1.  **Fragment：**

- Vue 3 允许多个根节点（Fragment），这使得组件模板可以有多个并列的根元素。
- Vue 2 要求每个组件必须有一个单独的根节点。

1.  **自定义渲染器 API：**

- Vue 3 提供了自定义渲染器 API，允许开发者创建自己的渲染逻辑。

1.  **更好的模块化：**

- Vue 3 对内部模块进行了更好的分离，使 tree-shaking 更加有效，有助于减小最终的打包体积。

1.  **静态元素提升（Static Hoisting）：**

- Vue 2 中，模板中的所有元素在每次重新渲染时都会被创建新的虚拟节点（VNodes），包括静态元素（不变的HTML和文本）。
- Vue 3 引入了静态元素提升的概念。在编译模板时，Vue 3 会检测出静态内容并将其提升，意味着这些内容只在初次渲染时创建一次。后续的渲染中，静态内容会被重用，从而减少了渲染开销和提升了性能。

1.  **虚拟节点静态标记（Patch Flag）：**

- Vue 2 在更新组件时，会进行相对全面的虚拟 DOM 比较，这可能会导致性能开销。
- Vue 3 引入了 Patch Flag，这是一种优化技术，它在编译时标记虚拟节点的动态部分。这样在组件更新时，Vue 只需要关注这些被标记的部分，而不是整个组件树，从而显著提升了性能。

1.  **生命周期变化：**

- Vue 2 提供了一系列的生命周期钩子，如 created , mounted , updated , destroyed 等。
- Vue 3 对这些生命周期钩子进行了重命名和调整，以更好地与 Composition API 配合。例如， beforeDestroy 和 destroyed 分别更名为 beforeUnmount 和 unmounted 。此外，Vue 3 引入了新的生命周期钩子，如 onMounted , onUpdated , onUnmounted 等，用于组合式 API。

1.  **打包体积优化：**

- Vue 2 的打包体积相对较大，尤其是在包含了全框架的所有特性时。
- Vue 3 进行了大量的打包体积优化。它采用了更有效的树摇（Tree-shaking）机制，允许去除未使用的代码部分。这意味着如果你只使用 Vue 的一部分功能，最终打包出来的文件会更小。
